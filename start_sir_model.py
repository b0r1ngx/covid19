# -*- coding: utf-8 -*-
"""Copy2, SIR_model.ipynb

Automatically generated by Colaboratory.

 Original file is located at
     https://colab.research.google.com/drive/1CWvLnoLcXY7I-iuEvMWYPCGKT-YMqZ04

# Лабораторная работа 5 
 Gentle Introduction to COVID 19 modelling

## SIR модель
 Попробуем здесь, вооружившись всем вновь изученным понять как могут быть устроены эпидемиологическим модели.
 Самая базовая модель, тем не менее довольно хорошо отражающая общую картину, так называемая  SIR - 
 модель была предложена аж в 1927. Kermack-McKendrick model (KM) была предложена
 в качестве модели распространения эпидемии грипа в 1905 году в Мумбаи. Данная модель позволяла лучше понять
 что просиходит, когда в замкнутую популяцию проникает носитель инфекции и как происходит распространение болезни.

 Предположения модели:
 - все население делится на три части: восприимчивые (Susceptible), инфицированные (Infected), имунные,
   то есть вылечившиеся или умершие( Removed).

 - популяция замкнутая, нет миграционных процессов, новорожденные не оказывают влияния на популяцию,
   как и умершие по другим причинам.

 - все люди одинаково восприимчивы к болезни
 
 И получилось у них следующее:
 
     $$ frac{dS}{dt} = -beta SI N^{-1} qquad [1]$$
     $$frac{dI}{dt} = N^{-1}beta SI - alpha I qquad [2]$$
     $$frac{dR}{dt} = alpha I qquad [3]$$


 Давайте не будем бояться этих уравнений (нам еще их программировать), попробуем повторить рассуждения и понять
 как интуиция превращается в формулы.

    $$S rightarrow  I rightarrow R $$

 - Первое уравнение. В популяцию попадает первый инфицированный и давай заражать. Будем считать,
 что каждый инфицированный (I) может заразить какое-то фиксированное количество восприимчивых.
 Пусть есть какая то скорость инфицирования $beta$ или количество контактов за определенный промежуток времени,
 при этом среди этих контактов будут и имунные, поэтому чтобы получить количество новых зараженных,
 которые произвел этот конкретный инфицированный, надо домножить $beta S/N$, где $N -$ размер популяции.
 Почему фиксированное? А как же суперспредеры и те кого заставили сидеть дома и дверь скотчем заклеили?
 Тут никак, задача написать такие уравнения, которые решать уже научились к 1927 году и концу нашего курса тоже:).
 Так вот если КАЖДЫЙ инфицированный заражает какое-то количество восприимчивых, то надо чтобы общее изменение за день
 еще домножить на число этих инфицированных. Вот и получили $-beta S I$. А почему минус кстати?
 
 - Последнее. Какое-то число из инфицированных каждый день выздоравливает или умирает,
 будем считать что тоже фиксированное, тоже для удобства. Тут это даже не сильно неправдоподобное допущение.
 
 - Второе. А тут выходит на поле допущение про замкнутую популяцию. $N = S +I + R$.
 А изменение (то самое страшное слово дифференциал или линейная вариация, что еще хуже)
 будет равно нулю $0 = dS + dI+dR$. И вот прямо отсюда получаем второе уравнение.
 
 - В модели у нас появились две константы, скорость инфицирования и выздоровления(и смерти).
 Если инфицирование происходит быстрее выздоровления, то начинается эпидемия, которая охватывает всю популяцию.
 Это и есть магическое $R_0 = frac{beta}{alpha}$, которое в фильме "Заражение" было около 3,
 а для covid  уже каких только цифр не называлось от 2 и до 5.

###  Решаем систему уравнений

 Вообще такие уравнения решать научились довольно давно, с ручкой и на бумажке.
 И в нашем новом технологичном мире после того, как уравнения написаны, решить их уже дело техники.
 Есть специальные библиотеки в которые можно отправить уравнения, а они обратно решения.
 !Но мы так делать не будем. Решим, используя то, что уже умеем.

####  Метод Эйлера 

 Будем искать, вместо точного аналитического решения, приближенное. Такой стандартный ход,
 особенно физики любят прикидки всякие делать. Но в данном случае решение довольно близкое получается к точному и
 даже специальное название имеет: метод Эйлера. А самое главное, что мы уже все знаем и умеем для него.

 Вспомним разложение в ряд Тейлора (горячо любимое),
 но ограничимся только первыми двумя членами (той самой линейной вариацией).

    $$f(t+h) = f(t) + f'(t)h$$

 Если теперь вспомнить про то, что у нас $S, I, R$  - функции от времени, то можно это разложени для всех троих выписать.
 А вместо производных подставить выражения из уравнений модели. Для $S - $ получится

    $$S(t+h) = S(t) - N^{-1}beta S(t)I(t)h$$
    $$I(t+h) = I(t) + (N^{-1}beta S(t)I(t) - alpha I(t)h $$

 в последнем уравнении давайте будем считать, что $R$ пропорционально все-таки текущему числу инфицированных,
 оно более реалистично, а код не усложнится

    $$R(t+h) = R(t)+ alpha I(t)h $$
"""
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

plt.rcParams["figure.figsize"] = (10, 5)


def sir_model(params, t_max=100, Npop=1000, I_0=1):
    # будем идти с шагом в один день

    S = np.zeros(t_max)
    I = np.zeros(t_max)
    R = np.zeros(t_max)

    S[0], I[0], R[0] = Npop - I_0, I_0, 0

    beta, alpha = params
    for i in range(1, t_max):
        S[i] = S[i - 1] - beta * S[i - 1] * I[i - 1] / Npop
        I[i] = I[i - 1] + beta * S[i - 1] * I[i - 1] / Npop - alpha * I[i - 1]
        R[i] = R[i - 1] + alpha * I[i - 1]

    return S, I, R


params = [0.05, 0.01]
Npop = 10000000
I_0 = 10
t_max = 1000
S, I, R = sir_model(params, t_max, Npop, I_0)
plt.plot(range(t_max), S, range(t_max), I, range(t_max), R)
plt.legend(['Susceptible', 'Infected', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

"""Итого, получили какие-то кривые, которые в общем отдаленно напоминают реальную картину. 
 А насколько далеко и как вообще сопоставить модель и реальность?

## Реальные данные

 Давайте посмотрим на реальные данные. Сейчас огромное количество откуда можно взять аггрегированные данные. 
 Ниже один из них. Заодно освежим навыки работы с табличками.
"""

covidData = pd.read_csv("C:/PycharmProjects/untitled/coronavirus.csv",
                        usecols=["date", "country", "type", "cases"])
covidData.head()

"""Посмотрим какие страны есть в списке"""

pd.unique(covidData["country"])


def agg_by_country(country, covidData=None):
    df = covidData[covidData["country"].str.contains(country)].drop("country", axis=1)
    df = df.pivot(index='date', columns='type')
    df.columns = ['confirmed', 'death', 'recovered']
    df = df[df.confirmed > 0]
    df['dailyRemoved'] = df.death + df.recovered
    df['Infected'] = df.confirmed.cumsum() - df.dailyRemoved.cumsum()
    df['Removed'] = df.dailyRemoved.cumsum()
    return df


country = "Germany"
covidCtr = agg_by_country("Germany", covidData=covidData)
covidCtr[["Infected", "Removed"]].plot()
plt.title(country)
plt.show()

covidCtr.head()

"""## Модели и реальность

 Если посмотреть на графики, то качественно (это когда смотришь на кривые и они какие-то похожие, одна изгибается, 
 и вторая как-то так же, вторая растет сначала быстро, а потом помедленнее и вторая также). 
 Вот это называется качественная картина, но в данном случае качественная картина такая: рано или поздно все переболеют,
 когда то будет больных очень много, а потом количество пойдет на спад. Но вообще если вдруг интересуют вопросы: 
 а когда максимум, а что потом, а как долго? и когда же когда. То тут интересуют числа, 
 это уже называется количественный анализ. Теперь как из похожих картинок получит те, которые сильнее похожи на данные. 

 Если вы посмотрите на формулы, то там есть так называемые параметры. Если менять параметры (попробуйте)  - форма кривых 
 тоже будет меняться. Нас интересует, а какими образом надо подобрать параметры, так чтобы они были больше похожи на то, 
 что мы видим?  Это называется оптимизационная задача. В оптимизационной задаче что-то оптимизируют, мы все знаем, 
 что когда оптимизируют (педагогический состав например, учебную нагрузку) - это хотят что-то уменьшить. 
 Вот и тут хочется уменьшить, Что уменьшать? Разницу между ответом модели и тем, что видим. Вот этим и займемся. 

 Кто-то большой и умный уже все написал, нам осталось только понять как этим пользоваться.
"""

#  с помощью этого мы будем оптимизировать
from scipy.optimize import least_squares

#  Это то, что мы будем оптимизировать
dataInfected = covidCtr.Infected.values
dataRemoved = covidCtr.Removed.values
t_max = 50
Npop = 40000000
I_0 = 1


#  тут пишем разницу между моделью и реальностью
def sir_residuals(params, dataInfected, dataRemoved, t_max, Npop, I_0=2):
    realI = dataInfected[:t_max]
    realR = dataRemoved[:t_max]
    S, I, R = sir_model(params, t_max, Npop, I_0)

    return np.abs(realI - I) + np.abs(realR - R)


S, I, R = sir_model(params, t_max, Npop, I_0)

x_opt = least_squares(sir_residuals, [0.1, 0.01], bounds=([0.00001, 0.000001], [1, 1]),
                      args=(dataInfected, dataRemoved, t_max, Npop)).x
print(x_opt)

S, I, R = sir_model(x_opt, t_max, Npop, I_0)
plt.plot(range(t_max), I, range(t_max), R)
plt.scatter(range(t_max), dataInfected[:t_max])
plt.scatter(range(t_max), dataRemoved[:t_max])
plt.legend(['Infected', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

"""не очень реалистично? давайте попробуем улучшать!

## SEIR модель (усложненная версия)

 $$ frac{dS}{dt} = -rhobeta frac{S(I+theta E)}{N} qquad [1]$$
 $$frac{dE}{dt} = rhobeta frac{S(I+theta E)}{N} - kappa E qquad [2]$$
 $$frac{dI}{dt} = kappa E - gamma I qquad [3]$$
 $$frac{dR}{dt} = gamma I qquad [4]$$

## Задание 1 (10 баллов)
 Хочется усложнить модель. Добавить как-то информацию о течении болезни, что мы сначала заражаемся и не знаем этого, 
 но уже носители болезни (буковка E (Exposed) , болезнь в инкубационном периоде) и эти ребята уже заразны, 
 но не так сильно как те, которые явно болеют. Социальное дистанцирование (оно тут кроется за какой-то буквой)
 Опишите в этом блоке словами что значит каждое уравнение (можно поискать в интернете)
"""


def full_seir_model(params, t_max=100, Npop=1000, I_0=1):
    # будем идти с шагом в один день

    S = np.zeros(t_max)
    E = np.zeros(t_max)
    I = np.zeros(t_max)
    R = np.zeros(t_max)

    S[0], E[0], I[0], R[0] = Npop - I_0, I_0, I_0, 0

    rho, beta, theta, kappa, gamma = params
    for i in range(1, t_max):
        S[i] = S[i - 1] - rho * beta * S[i - 1] * (I[i - 1] + theta * E[i - 1]) / Npop
        E[i] = E[i - 1] + rho * beta * S[i - 1] * (I[i - 1] + theta * E[i - 1]) / Npop - kappa * E[i - 1]
        I[i] = I[i - 1] + kappa * E[i - 1] - gamma * I[i - 1]
        R[i] = R[i - 1] + gamma * I[i - 1]

    return S, E, I, R


rho = 0.6
gamma = 1 / 15
theta = 0.6
beta = 4 / 15
kappa = 1 / 3
t_max = 150
Npop = 1000000
I_0 = 10
print(f"magic Rho is {beta / gamma}")
S, E, I, R = full_seir_model([rho, beta, theta, kappa, gamma], t_max, Npop, I_0)
plt.title('quest graph')
plt.plot(range(t_max), I, range(t_max), E, range(t_max), R)
plt.legend(['Infected', 'Exposed', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

dataInfected = covidCtr.Infected.values
dataRemoved = covidCtr.Removed.values
t_max = 45
Npop = 40000000
I_0 = 2


def full_seir_residuals(params, dataInfected, dataRemoved, t_max, Npop, I_0=2):
    realI = dataInfected[:t_max]
    realR = dataRemoved[:t_max]
    S, E, I, R = full_seir_model(params, t_max, Npop, I_0)

    return np.abs(realI - I) + np.abs(realR - R)


x_opt = least_squares(full_seir_residuals, [rho, beta, theta, kappa, gamma],
                      bounds=([0, 0.001, 0.000001, 0.0001, 0.001], [1, 1, 1, 1, 1]),
                      args=(dataInfected, dataRemoved, t_max, Npop)).x
print(x_opt, x_opt[1] / x_opt[4])

S, E, I, R = full_seir_model(x_opt, t_max, Npop, I_0)
plt.plot(range(t_max), I, range(t_max), R)
plt.scatter(range(t_max), dataInfected[:t_max])
plt.scatter(range(t_max), dataRemoved[:t_max])
plt.legend(['Infected', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

t_max = 220
S, E, I, R = full_seir_model(x_opt, t_max, Npop, I_0)

plt.plot(range(t_max), I, range(t_max), E, range(t_max), R)
plt.legend(['Infected', 'Exposed', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

"""https://towardsdatascience.com/social-distancing-to-slow-the-coronavirus-768292f04296
https://m.habr.com/ru/post/500348/

##  Задание 2 (20)
Напишите упрощенную модель   SEIR

 $$ frac{dS}{dt} = -beta frac{SI}{N} qquad [1]$$
 $$ frac{dE}{dt} = beta frac{SI}{N}  - kappa E qquad [2]$$
 $$ frac{dI}{dt} = kappa E - gamma I qquad [3]$$
 $$ frac{dR}{dt} = gamma I qquad [4]$$
 
"""


def simplified_seir_model(init_vals, params, t_max):
    S_0, E_0, I_0, R_0 = init_vals

    S, E, I, R = [S_0], [E_0], [I_0], [R_0]

    beta, kappa, gamma = params
    dt = t_max[1] - t_max[0]
    for _ in t[1:]:
        S.append(S[-1] - (beta * S[-1] * I[-1]) * dt)
        E.append(E[-1] + (beta * S[-1] * I[-1] - kappa * E[-1]) * dt)
        I.append(I[-1] + (kappa * E[-1] - gamma * I[-1]) * dt)
        R.append(R[-1] + (gamma * I[-1]) * dt)
    return [S, E, I, R]


# будем идти с шагом в 1 день
# определяем переменные
t_max = 100
dt = .1
t = np.linspace(0, t_max, int(t_max / dt) + 1)
N = 10000
init_vals = 1 - 1 / N, 1 / N, 0, 0
beta = 1.75
kappa = .2
gamma = .5
params = beta, kappa, gamma
print(f"magic Rho is {beta / gamma}")
# Run simulation
results = simplified_seir_model(init_vals, params, t)
plt.title('Упрощенная модель')
# I E R
plt.plot(t, results[2], t, results[1], t, results[3])
plt.legend(['Infected', 'Exposed', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

"""
##  Задание 3 (40)
 Выберите какую-нибудь страну для анализа и попробуйте оценить все три модели 
 и описать начало процесса
"""
#  Захотелось провести исследование для двух стран, на мой взгляд самых интересных.
# 1 Страна
# Будем использовать те же данные, что и преподаватель для некоторой страны.
params = [0.05, 0.01]
Npop = 10000000
I_0 = 10

country = "US"
covidCtr = agg_by_country(country, covidData=covidData)
covidCtr[["Infected", "Removed"]].plot()
plt.title('Модель по данным из файла, для Country:' + country)
plt.show()

US = agg_by_country("US", covidData=covidData)
print('US info, COVID-19\n', US.sum())

#  Это то, что мы будем оптимизировать под США
dataInfected = covidCtr.Infected.values
dataRemoved = covidCtr.Removed.values
t_max = 50
Npop = 40000000
I_0 = 1

S, I, R = sir_model(params, t_max, Npop, I_0)

x_opt = least_squares(sir_residuals, [0.1, 0.01], bounds=([0.00001, 0.000001], [1, 1]),
                      args=(dataInfected, dataRemoved, t_max, Npop)).x
print(x_opt)

S, I, R = sir_model(x_opt, t_max, Npop, I_0)
plt.title('Разница между моделью и реальностью, США')
plt.plot(range(t_max), I, range(t_max), R)
plt.scatter(range(t_max), dataInfected[:t_max])
plt.scatter(range(t_max), dataRemoved[:t_max])
plt.legend(['Infected', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

# SIR model
params = [0.05, 0.01]
Npop = 10000000
I_0 = 10
t_max = 1000
S, I, R = sir_model(params, t_max, Npop, I_0)
plt.title('Модель без Е зависимости, США')
plt.plot(range(t_max), S, range(t_max), I, range(t_max), R)
plt.legend(['Susceptible', 'Infected', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

# SEIR модель (усложненная версия)
rho = 0.6
gamma = 1 / 15
theta = 0.6
beta = 4 / 15
kappa = 1 / 3
t_max = 150
Npop = 1000000
I_0 = 10
print(f"magic Rho is {beta / gamma}")
S, E, I, R = full_seir_model([rho, beta, theta, kappa, gamma], t_max, Npop, I_0)

dataInfected = covidCtr.Infected.values
dataRemoved = covidCtr.Removed.values
t_max = 45
Npop = 40000000
I_0 = 2

x_opt = least_squares(full_seir_residuals, [rho, beta, theta, kappa, gamma],
                      bounds=([0, 0.001, 0.000001, 0.0001, 0.001], [1, 1, 1, 1, 1]),
                      args=(dataInfected, dataRemoved, t_max, Npop)).x
print(x_opt, x_opt[1] / x_opt[4])

S, E, I, R = full_seir_model(x_opt, t_max, Npop, I_0)
plt.plot(range(t_max), I, range(t_max), R)
plt.scatter(range(t_max), dataInfected[:t_max])
plt.scatter(range(t_max), dataRemoved[:t_max])
plt.legend(['Infected', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

t_max = 220
S, E, I, R = full_seir_model(x_opt, t_max, Npop, I_0)
plt.title('Усложненная модель, США')
plt.plot(range(t_max), I, range(t_max), E, range(t_max), R)
plt.legend(['Infected', 'Exposed', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()


# Упрощенная модель SEIR
t_max = 100
dt = .1
t = np.linspace(0, t_max, int(t_max / dt) + 1)
N = 10000
init_vals = 1 - 1 / N, 1 / N, 0, 0
beta = 1.75
kappa = .2
gamma = .5
params = beta, kappa, gamma
print(f"magic Rho is {beta / gamma}")
# Run simulation
results = simplified_seir_model(init_vals, params, t)
plt.title('Упрощенная модель, США')
plt.plot(t, results[2], t, results[1], t, results[3])
plt.legend(['Infected', 'Exposed', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

# 2 Страна
params = [0.05, 0.01]
Npop = 10000000
I_0 = 10

country = "Russia"
covidCtr = agg_by_country(country, covidData=covidData)
covidCtr[["Infected", "Removed"]].plot()
plt.title('Модель по данным из файла, для Country:' + country)
plt.show()

RU = agg_by_country("Russia", covidData=covidData)
print('Russia info, COVID-19\n', RU.sum())

#  Это то, что мы будем оптимизировать под Россию
dataInfected = covidCtr.Infected.values
dataRemoved = covidCtr.Removed.values
t_max = 50
Npop = 40000000
I_0 = 1

S, I, R = sir_model(params, t_max, Npop, I_0)

x_opt = least_squares(sir_residuals, [0.1, 0.01], bounds=([0.00001, 0.000001], [1, 1]),
                      args=(dataInfected, dataRemoved, t_max, Npop)).x
print(x_opt)

S, I, R = sir_model(x_opt, t_max, Npop, I_0)
plt.title('Разница между моделью и реальностью, Россия')
plt.plot(range(t_max), I, range(t_max), R)
plt.scatter(range(t_max), dataInfected[:t_max])
plt.scatter(range(t_max), dataRemoved[:t_max])
plt.legend(['Infected', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

# SIR model
params = [0.05, 0.01]
Npop = 10000000
I_0 = 10
t_max = 1000
S, I, R = sir_model(params, t_max, Npop, I_0)
plt.title('Модель без Е зависимости, Россия')
plt.plot(range(t_max), S, range(t_max), I, range(t_max), R)
plt.legend(['Susceptible', 'Infected', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

# SEIR модель (усложненная версия)
rho = 0.6
gamma = 1 / 15
theta = 0.6
beta = 4 / 15
kappa = 1 / 3
t_max = 150
Npop = 1000000
I_0 = 10
print(f"magic Rho is {beta / gamma}")
S, E, I, R = full_seir_model([rho, beta, theta, kappa, gamma], t_max, Npop, I_0)


dataInfected = covidCtr.Infected.values
dataRemoved = covidCtr.Removed.values
t_max = 45
Npop = 40000000
I_0 = 2

x_opt = least_squares(full_seir_residuals, [rho, beta, theta, kappa, gamma],
                      bounds=([0, 0.001, 0.000001, 0.0001, 0.001], [1, 1, 1, 1, 1]),
                      args=(dataInfected, dataRemoved, t_max, Npop)).x
print(x_opt, x_opt[1] / x_opt[4])
# 45 дней
S, E, I, R = full_seir_model(x_opt, t_max, Npop, I_0)
plt.plot(range(t_max), I, range(t_max), R)
plt.scatter(range(t_max), dataInfected[:t_max])
plt.scatter(range(t_max), dataRemoved[:t_max])
plt.legend(['Infected', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()
# 220 дней
t_max = 220
S, E, I, R = full_seir_model(x_opt, t_max, Npop, I_0)
plt.title('Усложненная модель, Россия')
plt.plot(range(t_max), I, range(t_max), E, range(t_max), R)
plt.legend(['Infected', 'Exposed', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()


# Упрощенная модель SEIR
t_max = 100
dt = .1
t = np.linspace(0, t_max, int(t_max / dt) + 1)
N = 10000
init_vals = 1 - 1 / N, 1 / N, 0, 0
beta = 1.75
kappa = .2
gamma = .5
params = beta, kappa, gamma
print(f"magic Rho is {beta / gamma}")
# Run simulation
results = simplified_seir_model(init_vals, params, t)
plt.title('Упрощенная модель, Россия')
plt.plot(t, results[2], t, results[1], t, results[3])
plt.legend(['Infected', 'Exposed', 'Recovered'])
plt.xlabel('Time Steps (In days)')
plt.show()

"""
## Задание 4 (30)

    $R_0 = {beta}/{alpha}$ 
  
 Параметр который чаще всего используется в сми и отвечает за скорость распространения инфекции.
 Предполагается, что этот параметр лежит в случае ковида в пределах от 3 до 6. 
 Добавьте данное ограничение при решении задачи оптимизации
"""

# Данный параметр, в задачах выше, таким и является, так что практически на наших моделях,
# мы только подтвердили эти слова из реальных данных.

# Добавлим это ограничение для решения задачи оптимизации:
alpha = 1
R_0 = beta / alpha  # [3, 6]
